<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple To-Do List</title>
    <style>
        /* CSS Reset and Base Styles */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --primary-color: #4a90e2;
            --danger-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --border-color: #dfe6e9;
            --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            background: var(--bg-primary);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2rem;
            font-weight: 600;
            margin: 0;
        }

        .input-section {
            padding: 30px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .task-list-section {
            padding: 0;
        }

        .task-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        /* Warning Banner */
        .warning-banner {
            background: var(--warning-color);
            color: white;
            padding: 12px 20px;
            margin: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .warning-banner button {
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0 8px;
        }

        .warning-banner button:hover {
            opacity: 0.8;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 30px;
            color: var(--text-secondary);
        }

        .empty-state p {
            font-size: 1.1rem;
            margin: 0;
        }

        /* Task Form Styling */
        .task-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .task-input {
            width: 100%;
            padding: 12px 15px;
            font-size: 1rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            transition: var(--transition);
            font-family: inherit;
        }

        .task-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .char-counter {
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-align: right;
        }

        .char-counter.warning {
            color: var(--warning-color);
            font-weight: 600;
        }

        .char-counter.danger {
            color: var(--danger-color);
            font-weight: 600;
        }

        .btn {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: var(--transition);
            font-family: inherit;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #357abd;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
        }

        .btn-primary:disabled {
            background: var(--border-color);
            cursor: not-allowed;
        }

        /* Task List Item Styling */
        .task-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            background: white;
            transition: var(--transition);
        }

        .task-item:hover {
            background: var(--bg-secondary);
        }

        .task-item:last-child {
            border-bottom: none;
        }

        .task-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--success-color);
        }

        .task-text {
            flex: 1;
            font-size: 1rem;
            line-height: 1.5;
            word-break: break-word;
        }

        .task-text.completed {
            text-decoration: line-through;
            color: var(--text-secondary);
            opacity: 0.7;
        }

        .task-actions {
            display: flex;
            gap: 8px;
        }

        .btn-icon {
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 4px 8px;
            color: var(--text-secondary);
            transition: var(--transition);
            border-radius: 4px;
        }

        .btn-icon:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .btn-delete:hover {
            color: var(--danger-color);
        }

        .btn-edit:hover {
            color: var(--primary-color);
        }

        /* Edit Mode Styling */
        .task-edit-input {
            flex: 1;
            padding: 8px 12px;
            font-size: 1rem;
            border: 2px solid var(--primary-color);
            border-radius: 6px;
            font-family: inherit;
        }

        .task-edit-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }

        .edit-char-counter {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .edit-char-counter.warning {
            color: var(--warning-color);
            font-weight: 600;
        }

        .edit-char-counter.danger {
            color: var(--danger-color);
            font-weight: 600;
        }

        .edit-actions {
            display: flex;
            gap: 4px;
        }

        .btn-save {
            color: var(--success-color);
        }

        .btn-save:hover {
            background: rgba(39, 174, 96, 0.1);
        }

        .btn-cancel {
            color: var(--danger-color);
        }

        .btn-cancel:hover {
            background: rgba(231, 76, 60, 0.1);
        }

        /* Drag and Drop Styling */
        .task-item[draggable="true"] {
            cursor: move;
        }

        .task-item.dragging {
            opacity: 0.5;
            background: var(--bg-secondary);
        }

        .task-item.drag-over {
            border-top: 3px solid var(--primary-color);
        }

        /* Responsive Design */
        @media (max-width: 640px) {
            body {
                padding: 10px;
            }

            .container {
                border-radius: 8px;
            }

            header h1 {
                font-size: 1.5rem;
            }

            .input-section {
                padding: 20px;
            }

            .task-item {
                padding: 14px 16px;
            }

            .task-actions {
                gap: 4px;
            }

            .btn-icon {
                font-size: 1.4rem;
            }
        }

        /* Smooth Transitions */
        .task-item {
            transition: background-color 0.2s ease, border-color 0.2s ease, opacity 0.2s ease;
        }

        .task-text {
            transition: all 0.3s ease;
        }

        .btn-icon {
            transition: all 0.2s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Simple To-Do List</h1>
        </header>
        
        <section class="input-section">
            <form id="taskForm" class="task-form">
                <div class="form-group">
                    <input 
                        type="text" 
                        id="taskInput" 
                        class="task-input" 
                        placeholder="What needs to be done?"
                        maxlength="500"
                        autocomplete="off"
                        aria-label="Task description"
                    >
                    <div class="char-counter">
                        <span id="charCount">0</span> / 500 characters
                    </div>
                </div>
                <button type="submit" class="btn btn-primary">Add Task</button>
            </form>
        </section>
        
        <section class="task-list-section">
            <ul id="taskList" class="task-list">
                <!-- Tasks will be rendered here -->
            </ul>
        </section>
    </div>
    
    <script>
        // ===== STATE MANAGEMENT =====
        let tasks = [];
        const STORAGE_KEY = 'todoApp.tasks';

        // ===== UTILITY FUNCTIONS =====
        
        /**
         * Generate unique task ID using crypto.randomUUID() with fallback
         */
        function generateTaskId() {
            if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                return crypto.randomUUID();
            }
            // Fallback UUID v4 generator
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        /**
         * Validate task text (non-empty, ≤500 chars)
         */
        function validateTaskText(text) {
            if (!text || text.trim().length === 0) {
                return { valid: false, error: 'Task cannot be empty' };
            }
            if (text.length > 500) {
                return { valid: false, error: 'Task cannot exceed 500 characters' };
            }
            return { valid: true };
        }

        /**
         * Sanitize task data loaded from storage
         */
        function sanitizeTaskData(loadedTasks) {
            if (!Array.isArray(loadedTasks)) {
                return [];
            }

            // Filter out invalid tasks
            let validTasks = loadedTasks.filter(task =>
                task.id &&
                task.text &&
                task.text.length > 0 &&
                task.text.length <= 500 &&
                typeof task.completed === 'boolean' &&
                typeof task.order === 'number'
            );

            // Ensure unique IDs
            const seenIds = new Set();
            validTasks = validTasks.filter(task => {
                if (seenIds.has(task.id)) return false;
                seenIds.add(task.id);
                return true;
            });

            // Fix order values (make sequential)
            validTasks.sort((a, b) => a.order - b.order);
            validTasks.forEach((task, index) => {
                task.order = index + 1;
            });

            // Fix timestamps if invalid
            validTasks.forEach(task => {
                if (!task.createdAt || typeof task.createdAt !== 'number') {
                    task.createdAt = Date.now();
                }
                if (!task.updatedAt || typeof task.updatedAt !== 'number' || task.updatedAt < task.createdAt) {
                    task.updatedAt = task.createdAt;
                }
            });

            return validTasks;
        }

        /**
         * Display warning banner to user
         */
        function showWarning(message) {
            const existingBanner = document.querySelector('.warning-banner');
            if (existingBanner) {
                existingBanner.remove();
            }

            const banner = document.createElement('div');
            banner.className = 'warning-banner';
            banner.innerHTML = `
                <span>${message}</span>
                <button onclick="this.parentElement.remove()" aria-label="Dismiss warning">×</button>
            `;

            const container = document.querySelector('.container');
            container.insertBefore(banner, container.firstChild);
        }

        // ===== STORAGE FUNCTIONS =====

        /**
         * Load tasks from LocalStorage
         */
        function loadTasksFromStorage() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    const parsed = JSON.parse(stored);
                    tasks = sanitizeTaskData(parsed);
                    tasks.sort((a, b) => a.order - b.order);
                } else {
                    tasks = [];
                }
            } catch (e) {
                console.error('Failed to load tasks:', e);
                showWarning('Tasks could not be loaded. Using in-memory storage. Changes may not persist.');
                tasks = [];
            }
        }

        /**
         * Save tasks to LocalStorage
         */
        function saveTasksToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
                return true;
            } catch (e) {
                console.error('Failed to save tasks:', e);
                if (e.name === 'QuotaExceededError') {
                    showWarning('Storage quota exceeded. Please delete some tasks.');
                } else {
                    showWarning('Tasks could not be saved. Changes may not persist.');
                }
                return false;
            }
        }

        // ===== TASK OPERATIONS =====

        /**
         * Create a new task
         */
        function createTask(text) {
            const validation = validateTaskText(text);
            if (!validation.valid) {
                showWarning(validation.error);
                return null;
            }

            // Increment order for existing tasks
            tasks.forEach(task => {
                task.order += 1;
            });

            const newTask = {
                id: generateTaskId(),
                text: text.trim(),
                completed: false,
                order: 1,
                createdAt: Date.now(),
                updatedAt: Date.now()
            };

            tasks.unshift(newTask);
            saveTasksToStorage();
            renderTaskList();
            
            return newTask;
        }

        /**
         * Render task list in DOM
         */
        function renderTaskList() {
            const taskList = document.getElementById('taskList');
            
            if (tasks.length === 0) {
                taskList.innerHTML = '<li class="empty-state"><p>No tasks yet. Add one above!</p></li>';
                return;
            }

            taskList.innerHTML = tasks.map(task => `
                <li class="task-item" data-task-id="${task.id}" draggable="true">
                    <input 
                        type="checkbox" 
                        class="task-checkbox" 
                        ${task.completed ? 'checked' : ''}
                        onchange="toggleTaskCompletion('${task.id}')"
                        aria-label="Mark task as ${task.completed ? 'incomplete' : 'complete'}"
                    >
                    <span class="task-text ${task.completed ? 'completed' : ''}" ondblclick="startEditTask('${task.id}')">${escapeHtml(task.text)}</span>
                    <div class="task-actions">
                        <button 
                            class="btn-icon btn-edit" 
                            onclick="startEditTask('${task.id}')"
                            aria-label="Edit task"
                            title="Edit task"
                        >✎</button>
                        <button 
                            class="btn-icon btn-delete" 
                            onclick="deleteTask('${task.id}')"
                            aria-label="Delete task"
                            title="Delete task"
                        >×</button>
                    </div>
                </li>
            `).join('');

            // Setup drag and drop event listeners
            setupDragAndDrop();
        }

        /**
         * Escape HTML to prevent XSS
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Delete a task
         */
        function deleteTask(taskId) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex === -1) {
                showWarning('Task not found');
                return null;
            }

            const deletedTask = tasks.splice(taskIndex, 1)[0];
            
            // Recalculate order values
            tasks.forEach((task, index) => {
                task.order = index + 1;
            });

            saveTasksToStorage();
            renderTaskList();
            
            return deletedTask;
        }

        /**
         * Toggle task completion
         */
        function toggleTaskCompletion(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) {
                showWarning('Task not found');
                return null;
            }

            task.completed = !task.completed;
            task.updatedAt = Date.now();
            
            saveTasksToStorage();
            renderTaskList();
            
            return task;
        }

        /**
         * Start editing a task
         */
        function startEditTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) {
                showWarning('Task not found');
                return;
            }

            const taskItem = document.querySelector(`[data-task-id="${taskId}"]`);
            const taskTextSpan = taskItem.querySelector('.task-text');
            const taskActions = taskItem.querySelector('.task-actions');
            
            // Create edit input
            const editInput = document.createElement('input');
            editInput.type = 'text';
            editInput.className = 'task-edit-input';
            editInput.value = task.text;
            editInput.maxLength = 500;
            
            // Create character counter
            const charCounter = document.createElement('div');
            charCounter.className = 'edit-char-counter';
            charCounter.textContent = `${task.text.length} / 500`;
            
            // Create save/cancel buttons
            const editActions = document.createElement('div');
            editActions.className = 'edit-actions';
            editActions.innerHTML = `
                <button class="btn-icon btn-save" title="Save">✓</button>
                <button class="btn-icon btn-cancel" title="Cancel">✗</button>
            `;
            
            // Replace text with edit mode
            taskTextSpan.style.display = 'none';
            taskActions.style.display = 'none';
            taskItem.appendChild(editInput);
            taskItem.appendChild(charCounter);
            taskItem.appendChild(editActions);
            
            editInput.focus();
            editInput.select();
            
            // Character counter update
            editInput.addEventListener('input', function() {
                const length = editInput.value.length;
                charCounter.textContent = `${length} / 500`;
                if (length > 450 && length <= 500) {
                    charCounter.classList.add('warning');
                } else if (length > 500) {
                    charCounter.classList.add('danger');
                } else {
                    charCounter.classList.remove('warning', 'danger');
                }
            });
            
            // Save button
            editActions.querySelector('.btn-save').addEventListener('click', function() {
                updateTask(taskId, editInput.value);
            });
            
            // Cancel button
            editActions.querySelector('.btn-cancel').addEventListener('click', function() {
                cancelEdit(taskId);
            });
            
            // Enter to save, Escape to cancel
            editInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    updateTask(taskId, editInput.value);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cancelEdit(taskId);
                }
            });
        }

        /**
         * Update task text
         */
        function updateTask(taskId, newText) {
            const validation = validateTaskText(newText);
            if (!validation.valid) {
                showWarning(validation.error);
                return null;
            }

            const task = tasks.find(t => t.id === taskId);
            if (!task) {
                showWarning('Task not found');
                return null;
            }

            task.text = newText.trim();
            task.updatedAt = Date.now();
            
            saveTasksToStorage();
            renderTaskList();
            
            return task;
        }

        /**
         * Cancel edit mode
         */
        function cancelEdit(taskId) {
            renderTaskList();
        }

        // ===== DRAG AND DROP =====
        
        let draggedTaskId = null;

        /**
         * Setup drag and drop event listeners
         */
        function setupDragAndDrop() {
            const taskItems = document.querySelectorAll('.task-item');
            
            taskItems.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('dragleave', handleDragLeave);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);
            });
        }

        /**
         * Handle drag start
         */
        function handleDragStart(e) {
            draggedTaskId = e.currentTarget.dataset.taskId;
            e.currentTarget.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        /**
         * Handle drag over
         */
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const targetItem = e.currentTarget;
            if (targetItem.dataset.taskId !== draggedTaskId) {
                targetItem.classList.add('drag-over');
            }
        }

        /**
         * Handle drag leave
         */
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        /**
         * Handle drop
         */
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const targetTaskId = e.currentTarget.dataset.taskId;
            
            if (draggedTaskId && targetTaskId && draggedTaskId !== targetTaskId) {
                reorderTask(draggedTaskId, targetTaskId);
            }
            
            e.currentTarget.classList.remove('drag-over');
        }

        /**
         * Handle drag end
         */
        function handleDragEnd(e) {
            document.querySelectorAll('.task-item').forEach(item => {
                item.classList.remove('dragging', 'drag-over');
            });
            draggedTaskId = null;
        }

        /**
         * Reorder task by moving it to target position
         */
        function reorderTask(draggedId, targetId) {
            const draggedIndex = tasks.findIndex(t => t.id === draggedId);
            const targetIndex = tasks.findIndex(t => t.id === targetId);
            
            if (draggedIndex === -1 || targetIndex === -1) {
                return;
            }

            // Remove dragged task and insert at target position
            const [draggedTask] = tasks.splice(draggedIndex, 1);
            tasks.splice(targetIndex, 0, draggedTask);
            
            // Recalculate order values
            tasks.forEach((task, index) => {
                task.order = index + 1;
            });
            
            // Update timestamp for moved task
            draggedTask.updatedAt = Date.now();
            
            saveTasksToStorage();
            renderTaskList();
        }

        // ===== INITIALIZATION =====
        
        document.addEventListener('DOMContentLoaded', function() {
            loadTasksFromStorage();
            renderTaskList();
            
            // Setup form submission
            const taskForm = document.getElementById('taskForm');
            const taskInput = document.getElementById('taskInput');
            const charCount = document.getElementById('charCount');

            taskForm.addEventListener('submit', function(e) {
                e.preventDefault();
                const text = taskInput.value.trim();
                
                if (text) {
                    const task = createTask(text);
                    if (task) {
                        taskInput.value = '';
                        charCount.textContent = '0';
                        updateCharCounterStyle(0);
                    }
                } else {
                    showWarning('Task cannot be empty');
                }
            });

            // Character counter
            taskInput.addEventListener('input', function() {
                const length = taskInput.value.length;
                charCount.textContent = length;
                updateCharCounterStyle(length);
            });

            console.log('To-Do App initialized with', tasks.length, 'tasks');
        });

        /**
         * Update character counter styling based on length
         */
        function updateCharCounterStyle(length) {
            const charCounter = document.querySelector('.char-counter');
            charCounter.classList.remove('warning', 'danger');
            
            if (length > 450 && length <= 500) {
                charCounter.classList.add('warning');
            } else if (length > 500) {
                charCounter.classList.add('danger');
            }
        }
    </script>
</body>
</html>
